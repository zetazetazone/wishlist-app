---
phase: 15-group-settings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260205000003_group_settings.sql
  - app/group/[id]/index.tsx
  - app/group/[id]/settings.tsx
  - app/group/[id]/_layout.tsx
  - components/groups/GroupViewHeader.tsx
autonomous: true

must_haves:
  truths:
    - "Group settings route exists at /group/[id]/settings and renders"
    - "Gear icon appears in GroupViewHeader and navigates to settings"
    - "Existing group detail screen works unchanged at /group/[id]"
    - "Database has invite_code column on groups table with unique constraint"
    - "Database has is_group_admin() SECURITY DEFINER function"
    - "Database has transfer_admin_role() function"
    - "RLS allows admin to remove other members"
    - "RLS allows admin to update member roles"
  artifacts:
    - path: "supabase/migrations/20260205000003_group_settings.sql"
      provides: "invite_code column, is_group_admin function, transfer_admin_role function, updated RLS policies"
      contains: "is_group_admin"
    - path: "app/group/[id]/index.tsx"
      provides: "Group detail screen (moved from [id].tsx)"
      min_lines: 50
    - path: "app/group/[id]/settings.tsx"
      provides: "Settings screen skeleton with section placeholders"
      min_lines: 40
    - path: "app/group/[id]/_layout.tsx"
      provides: "Stack navigator for [id] folder"
      min_lines: 10
  key_links:
    - from: "components/groups/GroupViewHeader.tsx"
      to: "app/group/[id]/settings"
      via: "gear icon onPress -> router.push"
      pattern: "router\\.push.*settings"
    - from: "supabase/migrations/20260205000003_group_settings.sql"
      to: "group_members table"
      via: "RLS policies for DELETE and UPDATE"
      pattern: "is_group_admin"
---

<objective>
Set up the database foundation and route structure for group settings.

Purpose: All subsequent plans (info editing, member management, invite codes) depend on the database migration (RLS policies, invite_code column, helper functions) and the route restructure (converting app/group/[id].tsx from a file to a folder with index + settings routes). This plan provides the skeleton that Plans 02 and 03 will fill in.

Output: Migration SQL file, restructured route folder, settings screen skeleton, gear icon on GroupViewHeader.
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-group-settings/15-RESEARCH.md
@supabase/migrations/20260202000003_fix_group_members_recursion.sql
@supabase/migrations/20260201000001_initial_schema.sql
@app/group/[id].tsx
@components/groups/GroupViewHeader.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for group settings</name>
  <files>supabase/migrations/20260205000003_group_settings.sql</files>
  <action>
Create a SQL migration file that does the following, in order:

1. **Add invite_code column to groups table:**
   - `ALTER TABLE public.groups ADD COLUMN IF NOT EXISTS invite_code TEXT UNIQUE;`
   - Backfill existing groups: `UPDATE public.groups SET invite_code = UPPER(SUBSTRING(md5(random()::text || id::text) FROM 1 FOR 6)) WHERE invite_code IS NULL;`
   - Make NOT NULL: `ALTER TABLE public.groups ALTER COLUMN invite_code SET NOT NULL;`
   - Set default for new groups: `ALTER TABLE public.groups ALTER COLUMN invite_code SET DEFAULT UPPER(SUBSTRING(md5(random()::text) FROM 1 FOR 6));`

2. **Create is_group_admin() SECURITY DEFINER function:**
   ```sql
   CREATE OR REPLACE FUNCTION public.is_group_admin(check_group_id UUID, check_user_id UUID)
   RETURNS BOOLEAN AS $$
   BEGIN
     RETURN EXISTS (
       SELECT 1 FROM public.group_members
       WHERE group_id = check_group_id
         AND user_id = check_user_id
         AND role = 'admin'
     );
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
   ```
   This mirrors the existing `is_group_member()` pattern from migration `20260202000003`. The SECURITY DEFINER attribute avoids RLS recursion when used in policies on group_members.

3. **Update DELETE policy on group_members to allow admin removal:**
   ```sql
   DROP POLICY IF EXISTS "Users can leave groups" ON public.group_members;
   CREATE POLICY "Users can leave or be removed from groups"
     ON public.group_members FOR DELETE
     USING (
       auth.uid() = user_id
       OR
       public.is_group_admin(group_id, auth.uid())
     );
   ```

4. **Add UPDATE policy on group_members for admin role changes:**
   ```sql
   CREATE POLICY "Admins can update member roles"
     ON public.group_members FOR UPDATE
     USING (public.is_group_admin(group_id, auth.uid()))
     WITH CHECK (public.is_group_admin(group_id, auth.uid()));
   ```

5. **Create transfer_admin_role() database function for atomic admin transfer:**
   ```sql
   CREATE OR REPLACE FUNCTION public.transfer_admin_role(
     p_group_id UUID,
     p_new_admin_id UUID
   ) RETURNS VOID AS $$
   DECLARE
     v_current_user_id UUID := auth.uid();
   BEGIN
     IF NOT public.is_group_admin(p_group_id, v_current_user_id) THEN
       RAISE EXCEPTION 'Only the current admin can transfer the admin role';
     END IF;
     IF NOT public.is_group_member(p_group_id, p_new_admin_id) THEN
       RAISE EXCEPTION 'New admin must be a group member';
     END IF;
     UPDATE public.group_members SET role = 'member'
       WHERE group_id = p_group_id AND user_id = v_current_user_id;
     UPDATE public.group_members SET role = 'admin'
       WHERE group_id = p_group_id AND user_id = p_new_admin_id;
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;
   ```

6. **Add RLS policy for invite_code access (any group member can read/update):**
   The existing "Admins can update their groups" policy on groups FOR UPDATE already covers admin updates. For regenerating invite codes by any member, we need an additional policy or use the existing groups UPDATE policy (which is admin-only). Per GSET-06 any member can regenerate. Add a specific function:
   ```sql
   CREATE OR REPLACE FUNCTION public.regenerate_invite_code(p_group_id UUID)
   RETURNS TEXT AS $$
   DECLARE
     v_new_code TEXT;
   BEGIN
     IF NOT public.is_group_member(p_group_id, auth.uid()) THEN
       RAISE EXCEPTION 'Only group members can regenerate invite codes';
     END IF;
     v_new_code := UPPER(SUBSTRING(md5(random()::text || p_group_id::text || now()::text) FROM 1 FOR 6));
     UPDATE public.groups SET invite_code = v_new_code WHERE id = p_group_id;
     RETURN v_new_code;
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;
   ```

Add comments on all new functions.
  </action>
  <verify>
Read the migration file and verify:
- invite_code column added with UNIQUE, NOT NULL, and DEFAULT
- is_group_admin() function created with SECURITY DEFINER STABLE
- DELETE policy replaced (old dropped, new created with admin OR self condition)
- UPDATE policy added for group_members
- transfer_admin_role() function created
- regenerate_invite_code() function created
- All functions reference is_group_member() or is_group_admin() (not direct table access that would recurse)
  </verify>
  <done>Migration file exists with all 6 components. SQL is syntactically valid. No direct group_members queries in RLS policies on group_members (all go through SECURITY DEFINER functions).</done>
</task>

<task type="auto">
  <name>Task 2: Restructure route from file to folder + install expo-clipboard</name>
  <files>app/group/[id]/index.tsx, app/group/[id]/_layout.tsx</files>
  <action>
1. **Install expo-clipboard:**
   Run: `cd /home/zetaz/wishlist-app && npx expo install expo-clipboard`

2. **Create app/group/[id]/ folder and move existing screen:**
   - Delete `app/group/[id].tsx` (after reading its content)
   - Create `app/group/[id]/index.tsx` with the EXACT same content from the old [id].tsx file. The only change: update relative import paths since we're now one level deeper.
     - `'../../utils/groups'` becomes `'../../../utils/groups'`
     - `'../../types'` becomes `'../../../types'`
     - `'../../constants/theme'` becomes `'../../../constants/theme'`
     - `'../../components/groups/GroupViewHeader'` becomes `'../../../components/groups/GroupViewHeader'`
     - `'../../components/groups/MemberCard'` becomes `'../../../components/groups/MemberCard'`
     - `'../../utils/countdown'` becomes `'../../../utils/countdown'`
     - `'../../lib/celebrations'` becomes `'../../../lib/celebrations'`

3. **Create `app/group/[id]/_layout.tsx`:**
   ```tsx
   import { Stack } from 'expo-router';

   export default function GroupLayout() {
     return (
       <Stack screenOptions={{ headerShown: false }}>
         <Stack.Screen name="index" />
         <Stack.Screen name="settings" />
       </Stack>
     );
   }
   ```
   This is a minimal Stack layout that allows navigating between the group detail and settings screens. Both screens manage their own headers, so `headerShown: false`.
  </action>
  <verify>
- `npx expo install expo-clipboard` completes without error
- `app/group/[id].tsx` no longer exists
- `app/group/[id]/index.tsx` exists with correct relative imports
- `app/group/[id]/_layout.tsx` exists with Stack navigator
- Run: `cd /home/zetaz/wishlist-app && npx tsc --noEmit 2>&1 | head -30` to check for import errors (some pre-existing TS errors are expected, but no NEW errors from the restructure)
  </verify>
  <done>Route restructured: [id].tsx converted to [id]/index.tsx + _layout.tsx. expo-clipboard installed. Existing group detail screen works identically at /group/[id]. No new TypeScript errors introduced.</done>
</task>

<task type="auto">
  <name>Task 3: Create settings screen skeleton and add gear icon to GroupViewHeader</name>
  <files>app/group/[id]/settings.tsx, components/groups/GroupViewHeader.tsx</files>
  <action>
1. **Add gear icon to GroupViewHeader:**
   - Add `onSettings?: () => void` and `groupId: string` to the `GroupViewHeaderProps` interface.
   - In the component, add a gear icon button to the right of the back button (or in the top-right area). Place it in the same row as the back button for natural positioning:
     ```
     <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: spacing.md }}>
       {/* Back button (existing) */}
       <TouchableOpacity onPress={onBack} ...>
         <MaterialCommunityIcons name="arrow-left" ... />
       </TouchableOpacity>

       {/* Settings gear icon (new) */}
       {onSettings && (
         <TouchableOpacity onPress={onSettings} style={{ same circular style as back button }}>
           <MaterialCommunityIcons name="cog" size={24} color={colors.white} />
         </TouchableOpacity>
       )}
     </View>
     ```
   - The gear icon is optional (rendered only when `onSettings` is provided) so existing usages don't break.

2. **Update the group detail screen (app/group/[id]/index.tsx) to pass onSettings:**
   - Import `useRouter` (already imported).
   - Pass `onSettings={() => router.push(`/group/${id}/settings`)}` to GroupViewHeader.

3. **Create settings screen skeleton (app/group/[id]/settings.tsx):**
   Create a new screen following the app's existing visual language (burgundy/gold theme, same imports pattern as [id]/index.tsx):

   ```tsx
   import { useState, useEffect } from 'react';
   import { View, Text, ScrollView, TouchableOpacity, ActivityIndicator, Alert, StatusBar } from 'react-native';
   import { MaterialCommunityIcons } from '@expo/vector-icons';
   import { useLocalSearchParams, useRouter, Stack } from 'expo-router';
   import { LinearGradient } from 'expo-linear-gradient';
   import { MotiView } from 'moti';
   import { supabase } from '../../../lib/supabase';
   import { colors, spacing, borderRadius, shadows } from '../../../constants/theme';
   ```

   The screen should:
   - Accept `{ id }` from `useLocalSearchParams`
   - Fetch group details + current user's membership role on mount
   - Show loading spinner while fetching
   - Show a header with back arrow and "Group Settings" title (using LinearGradient, matching the app's style)
   - Show sections as titled cards with placeholder content:
     - "Group Info" section (visible to admin only) - placeholder text "Group info editing will appear here"
     - "Members" section (visible to all) - placeholder text "Member management will appear here"
     - "Invite Code" section (visible to all) - placeholder text "Invite code management will appear here"
     - "Danger Zone" section (visible to non-admin: shows "Leave Group" placeholder; visible to admin: shows "Transfer Admin" placeholder)
   - Each section should be a white card with rounded corners, shadow, and burgundy section title, matching the existing card style patterns in the app.
   - The `isAdmin` boolean determines which sections are shown and what options appear.

   Key implementation detail: Fetch membership role like this:
   ```typescript
   const { data: membership } = await supabase
     .from('group_members')
     .select('role')
     .eq('group_id', id)
     .eq('user_id', user.id)
     .single();
   const isAdmin = membership?.role === 'admin';
   ```

   Also fetch group details for the header:
   ```typescript
   const { data: group } = await supabase
     .from('groups')
     .select('name, description, photo_url, mode, invite_code')
     .eq('id', id)
     .single();
   ```

   Store both `isAdmin` and `group` in state. Render section cards conditionally.
  </action>
  <verify>
- GroupViewHeader.tsx has optional `onSettings` prop and gear icon
- app/group/[id]/index.tsx passes `onSettings` to GroupViewHeader
- app/group/[id]/settings.tsx renders with section placeholders
- The gear icon navigates to the settings screen
- Settings screen shows admin vs non-admin sections correctly
- Run `npx tsc --noEmit 2>&1 | grep "settings\|GroupViewHeader" | head -20` to check for TypeScript errors in the new/modified files
  </verify>
  <done>GroupViewHeader has gear icon that navigates to /group/[id]/settings. Settings screen skeleton renders with conditional sections based on admin role. All placeholder sections are ready for Plans 02 and 03 to fill in.</done>
</task>

</tasks>

<verification>
1. Migration file syntactically valid (check for SQL syntax issues)
2. Route restructure works: /group/[id] still renders the group detail screen
3. Gear icon visible on GroupViewHeader, navigates to settings
4. Settings screen loads, shows correct sections based on admin role
5. No new TypeScript errors beyond pre-existing ones
</verification>

<success_criteria>
- Database migration ready for deployment with invite_code column, is_group_admin(), transfer_admin_role(), regenerate_invite_code(), updated RLS policies
- Route restructured from file to folder without breaking existing navigation
- expo-clipboard installed
- Settings screen accessible via gear icon with role-conditional sections
- All placeholder sections ready for Plans 02 and 03
</success_criteria>

<output>
After completion, create `.planning/phases/15-group-settings/15-01-SUMMARY.md`
</output>
