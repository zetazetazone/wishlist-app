---
phase: 12-group-photo-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260205000002_group_photo_storage_policies.sql
  - lib/storage.ts
  - components/groups/GroupAvatar.tsx
autonomous: true

must_haves:
  truths:
    - "Group admins can upload photos to their groups"
    - "Group photos display in UI when set"
    - "Groups without photos show initials-based fallback avatar"
    - "Group photo URLs are stored as paths, not full URLs"
  artifacts:
    - path: "supabase/migrations/20260205000002_group_photo_storage_policies.sql"
      provides: "RLS policies for group photo storage"
      contains: "Group admins can upload group photos"
    - path: "lib/storage.ts"
      provides: "Group photo upload and URL functions"
      exports: ["uploadGroupPhoto", "getGroupPhotoUrl"]
    - path: "components/groups/GroupAvatar.tsx"
      provides: "Reusable group avatar component with fallback"
      exports: ["GroupAvatar"]
  key_links:
    - from: "lib/storage.ts"
      to: "supabase.storage"
      via: "uploadGroupPhoto uses from('avatars').upload()"
      pattern: "from\\('avatars'\\)\\.upload"
    - from: "components/groups/GroupAvatar.tsx"
      to: "lib/storage.ts"
      via: "getGroupPhotoUrl import"
      pattern: "import.*getGroupPhotoUrl.*from.*storage"
    - from: "components/groups/GroupAvatar.tsx"
      to: "@gluestack-ui/themed"
      via: "Avatar, AvatarImage, AvatarFallbackText imports"
      pattern: "Avatar.*AvatarFallbackText"
---

<objective>
Implement group photo storage infrastructure by extending the existing avatar system established in Phase 7.

Purpose: Enable group admins to upload photos for their groups, with initials-based fallback avatars for groups without photos. This is the foundation for CRGRP-01 (photo during creation), GSET-03 (photo in settings), and GVIEW-01 (photo in group header).

Output:
- RLS migration extending avatars bucket for groups/
- uploadGroupPhoto() and getGroupPhotoUrl() in storage service
- GroupAvatar component with photo/initials fallback
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-group-photo-storage/12-RESEARCH.md

# Existing patterns to follow
@lib/storage.ts
@supabase/migrations/20260204000002_avatars_storage_policies.sql
@app/profile/[id].tsx
@types/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RLS policies for group photos in avatars bucket</name>
  <files>supabase/migrations/20260205000002_group_photo_storage_policies.sql</files>
  <action>
Create a new migration file to extend the avatars bucket RLS policies for group photos.

The migration must:
1. Add INSERT policy "Group admins can upload group photos" - allows authenticated users to upload to groups/{groupId}/ if they are admin of that group (check group_members table)
2. Add UPDATE policy "Group admins can update group photos" - same admin check pattern
3. Add DELETE policy "Group admins can delete group photos" - same admin check pattern

Use storage.foldername(name) to extract path components:
- (storage.foldername(name))[1] = 'groups' (first folder)
- (storage.foldername(name))[2]::uuid = groupId (second folder)

Pattern to follow from existing avatars_storage_policies.sql:
- Use WITH CHECK for INSERT
- Use USING and WITH CHECK for UPDATE
- Use USING for DELETE
- All policies TO authenticated

Note: SELECT is already handled by "Anyone can view avatars" policy since bucket is public.

DO NOT create a new bucket - reuse existing avatars bucket.
  </action>
  <verify>
Run: `cat supabase/migrations/20260205000002_group_photo_storage_policies.sql`
Confirm file contains:
- 3 policies (INSERT, UPDATE, DELETE)
- All check groups folder and admin role
- Uses storage.foldername() helper
  </verify>
  <done>Migration file exists with correct RLS policies for group photo CRUD by admins</done>
</task>

<task type="auto">
  <name>Task 2: Add group photo upload service functions</name>
  <files>lib/storage.ts</files>
  <action>
Extend lib/storage.ts with two new exported functions:

1. `uploadGroupPhoto(groupId: string): Promise<string | null>`
   - Request media library permissions using ImagePicker.requestMediaLibraryPermissionsAsync()
   - Launch image picker with:
     - mediaTypes: 'images'
     - allowsEditing: true
     - aspect: [16, 9] (group header aspect ratio, NOT 1:1 like user avatars)
     - quality: 0.85
   - Compress image using expo-image-manipulator:
     - Import: `import * as ImageManipulator from 'expo-image-manipulator'`
     - Create context: `ImageManipulator.manipulate(uri)`
     - Chain: `.resize({ width: 800 }).compress(0.8)`
     - Render: `.renderAsync()`
   - Convert to ArrayBuffer via fetch()
   - Upload to avatars bucket at path: `groups/${groupId}/${Date.now()}.${fileExt}`
   - Use upsert: true to allow replacing photos
   - Return data.path on success, null on failure/cancel

2. `getGroupPhotoUrl(path: string | null): string | null`
   - Return null if path is null
   - Use supabase.storage.from('avatars').getPublicUrl(path)
   - Return data.publicUrl

Key differences from uploadAvatar():
- Path structure: `groups/${groupId}/...` not `${userId}/...`
- Aspect ratio: [16, 9] not [1, 1]
- Add compression step (existing uploadAvatar() doesn't compress - don't break it)
- Parameter is groupId, not userId

Keep existing uploadAvatar() and getAvatarUrl() unchanged.
  </action>
  <verify>
Run: `grep -n "uploadGroupPhoto\|getGroupPhotoUrl" lib/storage.ts`
Confirm both functions are exported.
Run: `grep "ImageManipulator" lib/storage.ts`
Confirm compression import and usage.
  </verify>
  <done>lib/storage.ts exports uploadGroupPhoto() with compression and getGroupPhotoUrl()</done>
</task>

<task type="auto">
  <name>Task 3: Create GroupAvatar component with initials fallback</name>
  <files>components/groups/GroupAvatar.tsx</files>
  <action>
Create a new GroupAvatar component following the pattern from app/profile/[id].tsx.

Component requirements:
1. Props interface:
   - group: { name: string; photo_url: string | null } (minimal type for flexibility)
   - size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' (default 'lg')

2. Implementation:
   - Import Avatar, AvatarFallbackText, AvatarImage from '@gluestack-ui/themed'
   - Import getGroupPhotoUrl from '@/lib/storage'
   - Compute photoUrl = group.photo_url ? getGroupPhotoUrl(group.photo_url) : null
   - Create getGroupInitials(name: string) helper:
     - Split name on whitespace
     - Take first letter of up to 3 words
     - Uppercase and join
     - Examples: "Family" -> "F", "Work Team" -> "WT", "Book Club Friends" -> "BCF"
   - Return Avatar with bgColor="$primary500" (theme primary color)
   - Conditionally render AvatarImage only if photoUrl exists
   - Always render AvatarFallbackText with initials (gluestack handles visibility)

3. Export:
   - Named export: `export function GroupAvatar({ ... })`

Pattern from app/profile/[id].tsx to follow:
```tsx
<Avatar bgColor="$primary500" size={size}>
  {photoUrl && (
    <AvatarImage source={{ uri: photoUrl }} alt={group.name} />
  )}
  <AvatarFallbackText>{getGroupInitials(group.name)}</AvatarFallbackText>
</Avatar>
```

DO NOT import full Group type - use minimal inline type for props to avoid circular deps.
  </action>
  <verify>
Run: `cat components/groups/GroupAvatar.tsx`
Confirm:
- Imports from @gluestack-ui/themed
- Imports getGroupPhotoUrl from @/lib/storage
- Has getGroupInitials helper function
- Exports GroupAvatar component
Run: `npx tsc --noEmit 2>&1 | head -20`
Confirm no TypeScript errors in new file.
  </verify>
  <done>GroupAvatar component exists with photo display and initials fallback</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. File structure check:
   - supabase/migrations/20260205000002_group_photo_storage_policies.sql exists
   - lib/storage.ts has new exports
   - components/groups/GroupAvatar.tsx exists

2. TypeScript validation:
   - `npx tsc --noEmit` passes (or shows only pre-existing errors)

3. Export verification:
   - `grep -n "export" lib/storage.ts` shows uploadGroupPhoto and getGroupPhotoUrl
   - `grep -n "export" components/groups/GroupAvatar.tsx` shows GroupAvatar

4. Pattern compliance:
   - Migration uses storage.foldername() helper (matches existing pattern)
   - Upload function uses expo-image-manipulator for compression
   - Component uses gluestack-ui Avatar pattern
</verification>

<success_criteria>
Phase 12 success criteria mapped to deliverables:

1. "Group photos stored in Supabase storage bucket with proper policies"
   -> Task 1: RLS policies allow admin CRUD in groups/ folder

2. "Upload service handles image compression and format validation"
   -> Task 2: uploadGroupPhoto() compresses to 800px width, 0.8 quality

3. "Generated avatars display when no photo is set (initials-based)"
   -> Task 3: GroupAvatar renders AvatarFallbackText with initials

4. "Photo URLs update correctly in groups table"
   -> Task 2: uploadGroupPhoto() returns storage path (caller updates DB)
</success_criteria>

<output>
After completion, create `.planning/phases/12-group-photo-storage/12-01-SUMMARY.md`
</output>
