---
phase: 42-wishlist-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260219000001_v1.7_wishlist_visibility_rls.sql
autonomous: true

must_haves:
  truths:
    - "Private wishlists are invisible to non-owners via RLS"
    - "Public wishlists visible to users sharing groups with owner"
    - "Friends wishlists visible to mutual friends"
    - "For-others wishlists with linked_group_id visible to group members"
    - "Group members can add items to for-others wishlists they can access"
  artifacts:
    - path: "supabase/migrations/20260219000001_v1.7_wishlist_visibility_rls.sql"
      provides: "linked_group_id column, visibility-based RLS policies"
      contains: "linked_group_id UUID REFERENCES"
  key_links:
    - from: "wishlists SELECT policy"
      to: "are_friends() helper"
      via: "USING clause for friends visibility"
      pattern: "are_friends.*wishlists.user_id"
    - from: "wishlists SELECT policy"
      to: "is_group_member() helper"
      via: "USING clause for linked group access"
      pattern: "is_group_member.*linked_group_id"
    - from: "wishlist_items INSERT policy"
      to: "linked_group_id"
      via: "WITH CHECK for collaborative access"
      pattern: "linked_group_id IS NOT NULL"
---

<objective>
Create database migration that extends wishlists with group linking and implements visibility-based RLS policies.

Purpose: Enforce visibility rules at database level (security-critical). Without RLS enforcement, visibility filtering in app code can be bypassed.

Output: Migration file with linked_group_id column, constraints, indexes, and updated RLS policies for wishlists SELECT and wishlist_items INSERT.
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-wishlist-visibility/42-RESEARCH.md

# Existing migrations for patterns
@supabase/migrations/20260216000001_v1.7_multi_wishlist_foundation.sql
@supabase/migrations/20260218000002_add_wishlist_owner_fields.sql
@supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visibility RLS migration</name>
  <files>supabase/migrations/20260219000001_v1.7_wishlist_visibility_rls.sql</files>
  <action>
Create migration file with these parts (follow existing migration patterns):

**PART 1 - Add linked_group_id column:**
```sql
ALTER TABLE public.wishlists
  ADD COLUMN IF NOT EXISTS linked_group_id UUID REFERENCES public.groups(id) ON DELETE SET NULL;
```

**PART 2 - Index for group-based lookups:**
```sql
CREATE INDEX IF NOT EXISTS idx_wishlists_linked_group
  ON public.wishlists(linked_group_id)
  WHERE linked_group_id IS NOT NULL;
```

**PART 3 - CHECK constraint (linked_group_id only for for-others):**
```sql
ALTER TABLE public.wishlists
  ADD CONSTRAINT wishlists_linked_group_owner_type_check CHECK (
    linked_group_id IS NULL OR owner_type IN ('other_manual', 'other_user')
  );
```
Note: Use DROP CONSTRAINT IF EXISTS before ADD CONSTRAINT for idempotency.

**PART 4 - Drop existing SELECT policy and create visibility-based policy:**
```sql
DROP POLICY IF EXISTS "Users can view own wishlists" ON public.wishlists;

CREATE POLICY "Visibility-based wishlist access"
  ON public.wishlists FOR SELECT
  USING (
    -- Owner always sees own wishlists (all visibility levels)
    user_id = (SELECT auth.uid())
    OR
    -- Public wishlists: visible to users who share any group with owner
    (visibility = 'public' AND owner_type = 'self' AND EXISTS (
      SELECT 1 FROM public.group_members gm1
      JOIN public.group_members gm2 ON gm1.group_id = gm2.group_id
      WHERE gm1.user_id = wishlists.user_id
        AND gm2.user_id = (SELECT auth.uid())
    ))
    OR
    -- Friends visibility: visible to mutual friends
    (visibility = 'friends' AND public.are_friends(wishlists.user_id, (SELECT auth.uid())))
    OR
    -- Linked group: for-others wishlists visible to group members
    (linked_group_id IS NOT NULL AND public.is_group_member(linked_group_id, (SELECT auth.uid())))
  );
```

**PART 5 - Update wishlist_items INSERT policy for collaborative access:**
```sql
DROP POLICY IF EXISTS "Users can add own wishlist items" ON public.wishlist_items;
DROP POLICY IF EXISTS "Users can add wishlist items" ON public.wishlist_items;

CREATE POLICY "Users can add wishlist items"
  ON public.wishlist_items FOR INSERT
  WITH CHECK (
    -- User's own wishlist (any visibility)
    EXISTS (
      SELECT 1 FROM public.wishlists w
      WHERE w.id = wishlist_items.wishlist_id
        AND w.user_id = (SELECT auth.uid())
    )
    OR
    -- For-others wishlist with linked group membership
    EXISTS (
      SELECT 1 FROM public.wishlists w
      WHERE w.id = wishlist_items.wishlist_id
        AND w.linked_group_id IS NOT NULL
        AND w.owner_type IN ('other_manual', 'other_user')
        AND public.is_group_member(w.linked_group_id, (SELECT auth.uid()))
    )
  );
```

**PART 6 - Comments:**
Add COMMENT ON COLUMN for linked_group_id explaining purpose.
Add COMMENT ON POLICY for both new policies explaining visibility rules.

**PART 7 - Validation block:**
Use DO $$ block to:
1. Verify linked_group_id column exists
2. Verify constraint exists
3. Verify both policies exist
4. RAISE NOTICE with migration summary

Follow the exact validation pattern from 20260216000001_v1.7_multi_wishlist_foundation.sql.
  </action>
  <verify>
Run `npx supabase db reset` to apply all migrations. Check:
1. No errors during migration
2. `\d wishlists` shows linked_group_id column
3. `\dp wishlists` shows "Visibility-based wishlist access" policy
4. `\dp wishlist_items` shows "Users can add wishlist items" policy
  </verify>
  <done>
Migration file exists at supabase/migrations/20260219000001_v1.7_wishlist_visibility_rls.sql.
Database schema includes linked_group_id column with constraint.
RLS policies enforce visibility rules: private=owner-only, public=group-co-members, friends=mutual-friends, linked_group=group-members.
Collaborative INSERT works for for-others wishlists with linked group access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Regenerate TypeScript types</name>
  <files>types/database.types.ts</files>
  <action>
Run `npx supabase gen types typescript --local > types/database.types.ts` to update TypeScript types with the new linked_group_id column.

After regeneration, verify the Wishlist type includes:
- linked_group_id: string | null

The types should already include visibility, owner_type, for_user_id, for_name from previous migrations.
  </action>
  <verify>
Grep types/database.types.ts for "linked_group_id" - should find it in wishlists Row, Insert, and Update types.
Run `npx tsc --noEmit` to verify no type errors introduced.
  </verify>
  <done>
TypeScript types regenerated and include linked_group_id column.
No TypeScript errors from the type changes.
  </done>
</task>

</tasks>

<verification>
1. Database migration applies without errors
2. linked_group_id column exists with FK constraint
3. wishlists_linked_group_owner_type_check constraint enforced
4. RLS policies show correct visibility logic
5. TypeScript types include linked_group_id
6. No type errors in codebase
</verification>

<success_criteria>
- Migration file created following project conventions
- All RLS policies correctly enforce visibility rules
- TypeScript types updated
- Database reset succeeds with all validations passing
</success_criteria>

<output>
After completion, create `.planning/phases/42-wishlist-visibility/42-01-SUMMARY.md`
</output>
