---
phase: 30-server-integration-translation-files
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - app/_layout.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User's language preference loads from server on app launch"
    - "Changing devices preserves user's selected language"
    - "Language syncs automatically when user logs in (no manual action needed)"
  artifacts:
    - path: "app/_layout.tsx"
      provides: "useLanguage integration with auth session"
      contains: "useLanguage"
  key_links:
    - from: "app/_layout.tsx"
      to: "hooks/useLanguage.ts"
      via: "import { useLanguage }"
      pattern: "useLanguage\\(.*\\?.*id"
    - from: "app/_layout.tsx"
      to: "syncFromServer"
      via: "useEffect callback"
      pattern: "syncFromServer\\(\\)"
---

<objective>
Wire useLanguage hook into app root layout to sync language preference from server on login

Purpose: Close PERS-03 gap - the useLanguage hook was created but never integrated into app code. Without this wiring, language preference cannot sync across devices when a user logs in.

Output: app/_layout.tsx modified to use useLanguage hook with userId from auth session
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-server-integration-translation-files/30-VERIFICATION.md

# Source files to understand integration pattern
@hooks/useLanguage.ts
@app/_layout.tsx
@src/i18n/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate useLanguage hook with auth session in root layout</name>
  <files>app/_layout.tsx</files>
  <action>
Modify app/_layout.tsx to integrate the useLanguage hook. Follow these EXPLICIT wiring steps:

**STEP 1: Add imports at top of file**
```typescript
import { useLanguage } from '../hooks/useLanguage';
import { initI18n } from '../src/i18n';
```

**STEP 2: Add state for i18n initialization and userId tracking**
Inside RootLayout component, after existing useState declarations:
```typescript
const [i18nReady, setI18nReady] = useState(false);
const [userId, setUserId] = useState<string | undefined>(undefined);
```

**STEP 3: Initialize i18n BEFORE using useLanguage**
Add a new useEffect at the beginning (before the auth useEffect):
```typescript
useEffect(() => {
  initI18n().then(() => setI18nReady(true));
}, []);
```

**STEP 4: Extract userId from existing auth state management**
The current _layout.tsx already has `supabase.auth.getSession()` calls. Locate these two places:

4a. In the initial session check (around line 21):
   AFTER the line `supabase.auth.getSession().then(async ({ data: { session } }) => {`
   ADD: `setUserId(session?.user?.id);`

4b. In onAuthStateChange callback (around line 53):
   Inside `supabase.auth.onAuthStateChange(async (_event, session) => {`
   ADD: `setUserId(session?.user?.id);`

**STEP 5: Call useLanguage hook with userId**
After the useState declarations, add:
```typescript
const { syncFromServer } = useLanguage(userId);
```

**STEP 6: Add useEffect to sync language when userId becomes available**
```typescript
useEffect(() => {
  if (userId && i18nReady) {
    syncFromServer();
  }
}, [userId, i18nReady, syncFromServer]);
```

**STEP 7: Guard rendering until i18n is ready**
Before the return statement (before `return (`), add:
```typescript
if (!i18nReady) return null;
```

IMPORTANT NOTES:
- Do NOT create a separate LanguageProvider - the root layout IS the provider context
- The existing supabase.auth.onAuthStateChange already tracks session - we're extracting userId from it
- The userId state triggers re-renders when user logs in/out, which triggers the sync

VERIFICATION THAT WIRING IS CORRECT:
- When user logs in: session becomes available -> setUserId called -> userId state changes -> useEffect triggers -> syncFromServer() executes
- On app launch with existing session: getSession returns session -> setUserId called -> syncFromServer() executes
  </action>
  <verify>
1. Run `npx tsc --noEmit` - should pass (no new type errors)
2. Search for import: `grep -n "useLanguage" app/_layout.tsx` - should find import and usage
3. Search for syncFromServer call: `grep -n "syncFromServer" app/_layout.tsx` - should find useEffect calling it
4. Verify userId extraction: `grep -n "setUserId" app/_layout.tsx` - should find 2 calls (getSession and onAuthStateChange)
  </verify>
  <done>
- app/_layout.tsx imports useLanguage from hooks/useLanguage.ts
- userId state extracted from both getSession() and onAuthStateChange()
- useLanguage called with userId
- syncFromServer() called in useEffect when userId becomes available
- i18n initialized before hook usage
- TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify integration wiring with grep checks</name>
  <files>app/_layout.tsx</files>
  <action>
Verify the integration is complete with specific pattern checks:

1. Confirm useLanguage import exists:
   ```bash
   grep -n "import.*useLanguage" app/_layout.tsx
   ```
   Should return line with import statement

2. Confirm userId state is created:
   ```bash
   grep -n "useState.*userId" app/_layout.tsx
   ```
   Should show `const [userId, setUserId] = useState`

3. Confirm userId is extracted in BOTH auth callbacks:
   ```bash
   grep -c "setUserId" app/_layout.tsx
   ```
   Should return 2 (one in getSession callback, one in onAuthStateChange)

4. Confirm useLanguage is called with userId:
   ```bash
   grep -n "useLanguage(userId)" app/_layout.tsx
   ```
   Should find the hook call

5. Confirm syncFromServer is called when userId is available:
   ```bash
   grep -B2 -A3 "syncFromServer" app/_layout.tsx
   ```
   Should show useEffect with userId dependency calling syncFromServer

6. Confirm i18n guard exists:
   ```bash
   grep -n "i18nReady" app/_layout.tsx
   ```
   Should find useState, initialization, and guard check

If any check fails, the wiring is incomplete - fix before marking done.
  </action>
  <verify>
All 6 grep checks pass:
1. useLanguage import exists
2. userId state exists
3. setUserId called twice (both auth callbacks)
4. useLanguage(userId) called
5. syncFromServer in useEffect with userId
6. i18nReady guard in place
  </verify>
  <done>
- All key links verified via grep patterns
- useLanguage hook is no longer orphaned (imported and used in app code)
- Wiring connects auth session -> userId state -> useLanguage hook -> syncFromServer
- PERS-03 requirement code changes complete
  </done>
</task>

</tasks>

<verification>
- [ ] `grep -n "useLanguage" app/_layout.tsx` returns import and usage lines
- [ ] `grep -n "syncFromServer" app/_layout.tsx` returns useEffect calling syncFromServer
- [ ] `grep -c "setUserId" app/_layout.tsx` returns 2
- [ ] `npx tsc --noEmit` passes without new type errors
- [ ] Hook is wired with userId from auth session (not undefined)
</verification>

<success_criteria>
1. useLanguage hook imported and called in app/_layout.tsx
2. userId extracted from BOTH supabase.auth.getSession() and onAuthStateChange callbacks
3. syncFromServer() called when user session becomes available
4. TypeScript compilation passes
5. PERS-03 gap closed - hook no longer orphaned
</success_criteria>

<runtime_verification_note>
This plan implements the CODE WIRING only. Runtime verification (confirming syncFromServer actually executes on login, verifying language syncs across devices) requires human testing with real app deployment. These runtime behaviors are documented in 30-VERIFICATION.md and should be tested during UAT:
- Login with account that has Spanish preference set on another device
- Verify app displays Spanish after login completes
- This cannot be automated as it requires actual Supabase session and multi-device scenario
</runtime_verification_note>

<output>
After completion, create `.planning/phases/30-server-integration-translation-files/30-05-SUMMARY.md`
</output>
