---
phase: 23-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql
autonomous: true

must_haves:
  truths:
    - "friends table exists with ordered bidirectional constraint (user_a_id < user_b_id)"
    - "friend_requests table exists with status enum (pending/accepted/rejected/blocked)"
    - "public_dates table exists with month/day columns for annual recurrence"
    - "are_friends() helper function returns correct boolean for any user pair"
    - "accept_friend_request() RPC atomically creates friendship and updates request status"
    - "users table has phone column with E.164 format unique constraint"
  artifacts:
    - path: "supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql"
      provides: "Complete v1.4 database foundation"
      contains: "CREATE TABLE public.friends"
  key_links:
    - from: "RLS policies on friends"
      to: "are_friends() helper function"
      via: "SECURITY DEFINER function call"
      pattern: "public\\.are_friends\\("
    - from: "accept_friend_request() RPC"
      to: "friends table"
      via: "INSERT with ordered constraint"
      pattern: "LEAST.*GREATEST"
---

<objective>
Create the complete database foundation for the v1.4 Friends System including three new tables (friends, friend_requests, public_dates), the are_friends() helper function, the accept_friend_request() RPC, and phone column on users table.

Purpose: Establish all database infrastructure needed by subsequent v1.4 phases (24-28) for friend management, friend discovery via phone contacts, and public date visibility.

Output: Single comprehensive migration file following established v1.3 pattern with clear PART sections, detailed comments, and SECURITY DEFINER functions.
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-database-foundation/23-CONTEXT.md
@.planning/phases/23-database-foundation/23-RESEARCH.md
@supabase/migrations/20260206000001_v1.3_claims_details_notes.sql
@supabase/migrations/20260202000003_fix_group_members_recursion.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v1.4 Friends System foundation migration</name>
  <files>supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql</files>
  <action>
Create comprehensive migration file with clear PART sections following v1.3 pattern:

**PART 1: friends table**
- Columns: id (UUID PK), user_a_id (FK users), user_b_id (FK users), created_at (TIMESTAMPTZ)
- CHECK constraint: `user_a_id < user_b_id` (ordered bidirectional - prevents duplicate rows)
- UNIQUE constraint on (user_a_id, user_b_id)
- Indexes: idx_friends_user_a, idx_friends_user_b
- Enable RLS

**PART 2: friend_requests table**
- Columns: id (UUID PK), from_user_id (FK users), to_user_id (FK users), status (TEXT), created_at, updated_at
- CHECK constraint on status: IN ('pending', 'accepted', 'rejected', 'blocked')
- Partial unique index on (LEAST(from_user_id, to_user_id), GREATEST(from_user_id, to_user_id)) WHERE status = 'pending' (prevents duplicate pending requests in either direction)
- Indexes: idx_friend_requests_to_status, idx_friend_requests_from
- Enable RLS

**PART 3: public_dates table**
- Columns: id (UUID PK), user_id (FK users), title (TEXT NOT NULL), description (TEXT), month (INT 1-12), day (INT 1-31), year (INT nullable for one-time events), created_at, updated_at
- CHECK constraints: month BETWEEN 1 AND 12, day BETWEEN 1 AND 31
- Indexes: idx_public_dates_user, idx_public_dates_month_day
- Enable RLS

**PART 4: Add phone column to users table**
- `ALTER TABLE public.users ADD COLUMN IF NOT EXISTS phone TEXT`
- UNIQUE constraint on phone (nullable unique - allows multiple NULL but not duplicate phones)
- Partial index: `CREATE UNIQUE INDEX idx_users_phone ON public.users(phone) WHERE phone IS NOT NULL`
- Comment: E.164 format (e.g., +14155551234), normalized at application layer via libphonenumber-js

**PART 5: are_friends() helper function**
Following is_group_member() pattern from 20260202000003:
```sql
CREATE OR REPLACE FUNCTION public.are_friends(p_user_a UUID, p_user_b UUID)
RETURNS BOOLEAN AS $$
BEGIN
  IF p_user_a IS NULL OR p_user_b IS NULL THEN
    RETURN FALSE;
  END IF;
  IF p_user_a = p_user_b THEN
    RETURN FALSE;
  END IF;
  RETURN EXISTS (
    SELECT 1 FROM public.friends
    WHERE user_a_id = LEAST(p_user_a, p_user_b)
      AND user_b_id = GREATEST(p_user_a, p_user_b)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

**PART 6: RLS policies for friends table**
Pattern: Friends-only visibility (both parties can see their friendships)
- SELECT: Either user in the friendship
- INSERT: Via accept_friend_request RPC only (no direct INSERT policy)
- UPDATE: Not allowed (friendships don't have mutable fields)
- DELETE: Either user can unfriend (delete the row)

**PART 7: RLS policies for friend_requests table**
- SELECT: Sender or receiver can view
- INSERT: Authenticated user as from_user_id, cannot send to self, no existing blocked status
- UPDATE: Receiver can update status (accept/reject), cannot change users
- DELETE: Sender can cancel pending request

**PART 8: RLS policies for public_dates table**
Pattern: Owner write, friends read
- SELECT: Owner OR are_friends(user_id, auth.uid())
- INSERT: Owner only
- UPDATE: Owner only
- DELETE: Owner only

**PART 9: Triggers**
- updated_at trigger on friend_requests (reuse handle_updated_at)
- updated_at trigger on public_dates (reuse handle_updated_at)
- No trigger on friends (no updated_at column)

**PART 10: accept_friend_request() RPC function**
```sql
CREATE OR REPLACE FUNCTION public.accept_friend_request(p_request_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_request RECORD;
  v_user_id UUID;
  v_friend_id UUID;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Lock the request row
  SELECT id, from_user_id, to_user_id, status
  INTO v_request
  FROM public.friend_requests
  WHERE id = p_request_id
  FOR UPDATE;

  IF v_request IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Request not found');
  END IF;

  -- Only receiver can accept
  IF v_request.to_user_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized to accept this request');
  END IF;

  -- Must be pending
  IF v_request.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Request is not pending');
  END IF;

  -- Create friendship with ordered IDs
  INSERT INTO public.friends (user_a_id, user_b_id)
  VALUES (
    LEAST(v_request.from_user_id, v_request.to_user_id),
    GREATEST(v_request.from_user_id, v_request.to_user_id)
  );

  -- Update request status
  UPDATE public.friend_requests
  SET status = 'accepted', updated_at = NOW()
  WHERE id = p_request_id;

  v_friend_id := v_request.from_user_id;
  RETURN jsonb_build_object('success', true, 'friend_id', v_friend_id);

EXCEPTION
  WHEN unique_violation THEN
    -- Already friends (race condition safety)
    RETURN jsonb_build_object('success', false, 'error', 'Already friends');
  WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;
```

**PART 11: Function permissions**
- GRANT EXECUTE on are_friends to authenticated
- GRANT EXECUTE on accept_friend_request to authenticated

**PART 12: Comments**
- Document tables, columns, RLS patterns
- Document functions with purpose and behavior

**PART 13: Completion notice**
- DO block with RAISE NOTICE summarizing migration
  </action>
  <verify>
File exists at supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql with:
- `grep -c "CREATE TABLE" supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql` returns 3
- `grep "CHECK.*user_a_id < user_b_id" supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql` finds constraint
- `grep "CREATE.*FUNCTION.*are_friends" supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql` finds helper
- `grep "CREATE.*FUNCTION.*accept_friend_request" supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql` finds RPC
- `grep "ALTER TABLE public.users ADD COLUMN.*phone" supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql` finds phone column
  </verify>
  <done>
Migration file contains all 13 PARTS: 3 tables (friends, friend_requests, public_dates), phone column on users, are_friends() helper, accept_friend_request() RPC, all RLS policies, triggers, permissions, and comments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply migration and verify schema</name>
  <files>supabase/migrations/20260210000001_v1.4_friends_system_foundation.sql</files>
  <action>
Apply the migration to the local Supabase database and verify all objects were created correctly.

1. Reset and apply migrations:
```bash
npx supabase db reset
```
This will apply all migrations including the new v1.4 foundation.

2. If db reset fails, check migration SQL syntax:
```bash
npx supabase db lint
```

3. After successful reset, verify tables exist via psql or Supabase Studio.

Note: The `npx supabase db reset` command will drop all data and re-apply all migrations. This is the standard verification approach for local development.
  </action>
  <verify>
Run `npx supabase db reset` - should complete without errors.
Migration output should include:
- "v1.4 Friends System Foundation migration completed successfully!"
- Tables created: friends, friend_requests, public_dates
- Functions created: are_friends, accept_friend_request
  </verify>
  <done>
Migration applies cleanly. All tables (friends, friend_requests, public_dates) exist with correct constraints. Helper function are_friends() and RPC accept_friend_request() are callable. Phone column exists on users table with unique constraint.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema verification via migration success output
2. `npx supabase db reset` completes without errors
3. All 13 PARTS present in migration file
4. Ordered bidirectional constraint prevents duplicate friendships
5. Friend request status enum enforced
6. Public dates have month/day columns
7. are_friends() helper available for RLS policies
8. accept_friend_request() atomically creates friendships
9. Phone column on users with unique partial index
</verification>

<success_criteria>
Phase 23 Database Foundation is complete when:
- [ ] Migration file exists with all 13 PARTS
- [ ] 3 new tables created (friends, friend_requests, public_dates)
- [ ] friends table has CHECK (user_a_id < user_b_id) constraint
- [ ] friend_requests has status enum (pending/accepted/rejected/blocked)
- [ ] public_dates has month (1-12) and day (1-31) columns
- [ ] are_friends() SECURITY DEFINER helper function created
- [ ] accept_friend_request() SECURITY DEFINER RPC created
- [ ] users.phone column added with unique partial index
- [ ] All RLS policies enforce correct visibility patterns
- [ ] Migration applies cleanly via `npx supabase db reset`
</success_criteria>

<output>
After completion, create `.planning/phases/23-database-foundation/23-01-SUMMARY.md`
</output>
