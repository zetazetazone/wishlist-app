---
phase: 02-celebrations-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260202000005_celebrations.sql
  - types/database.types.ts
  - lib/celebrations.ts
  - app/(app)/celebration/[id].tsx
  - app/(app)/(tabs)/celebrations.tsx
  - components/celebrations/CelebrationCard.tsx
  - components/celebrations/GiftLeaderBadge.tsx
autonomous: true

must_haves:
  truths:
    - "Gift Leader is automatically assigned based on birthday order when celebration is created"
    - "Gift Leader sees clear badge/indicator on celebration cards and detail screen"
    - "Group admin can reassign Gift Leader from celebration detail screen"
    - "Users can see list of celebrations they have access to (excluding own)"
    - "Celebrant CANNOT see chat room or contributions for their own celebration"
  artifacts:
    - path: "supabase/migrations/20260202000005_celebrations.sql"
      provides: "Database schema for celebrations, chat_rooms, chat_messages, celebration_contributions, gift_leader_history"
      contains: "celebrant_id != auth.uid()"
    - path: "lib/celebrations.ts"
      provides: "Celebration CRUD, Gift Leader assignment and reassignment"
      exports: ["createCelebration", "getNextGiftLeader", "reassignGiftLeader", "getCelebrations"]
    - path: "app/(app)/(tabs)/celebrations.tsx"
      provides: "Celebrations tab with list of accessible celebrations"
      min_lines: 80
    - path: "app/(app)/celebration/[id].tsx"
      provides: "Celebration detail screen with Gift Leader UI and reassignment"
      min_lines: 150
  key_links:
    - from: "lib/celebrations.ts"
      to: "supabase celebrations table"
      via: "supabase client queries"
      pattern: "from\\('celebrations'\\)"
    - from: "app/(app)/(tabs)/celebrations.tsx"
      to: "lib/celebrations.ts"
      via: "getCelebrations import"
      pattern: "import.*getCelebrations.*from.*celebrations"
    - from: "supabase/migrations/20260202000005_celebrations.sql"
      to: "RLS celebrant exclusion"
      via: "policy check"
      pattern: "celebrant_id != auth\\.uid\\(\\)"
---

<objective>
Create the celebrations system with database schema, Gift Leader assignment, and celebration screens.

Purpose: Establishes the foundation for coordinated birthday gift-giving with automatic Gift Leader rotation and celebration tracking. The RLS policies are security-critical to prevent celebrants from seeing their own surprise.

Output:
- Database migration with 5 new tables and comprehensive RLS policies
- Gift Leader assignment utility using birthday rotation algorithm
- Celebrations list tab showing accessible celebrations
- Celebration detail screen with Gift Leader UI and admin reassignment
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-celebrations-coordination/02-RESEARCH.md
@.planning/phases/02-celebrations-coordination/02-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@types/database.types.ts
@supabase/migrations/20260201000001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create celebrations database schema with RLS</name>
  <files>
    supabase/migrations/20260202000005_celebrations.sql
    types/database.types.ts
  </files>
  <action>
Create a comprehensive migration file with 5 tables. Follow exact patterns from 02-RESEARCH.md Code Examples section.

**Tables to create:**

1. `celebrations` - One per birthday per year
   - id (UUID, PK, gen_random_uuid())
   - group_id (UUID, FK groups, NOT NULL, CASCADE)
   - celebrant_id (UUID, FK users, NOT NULL, CASCADE)
   - event_date (DATE, NOT NULL)
   - year (INTEGER, NOT NULL)
   - gift_leader_id (UUID, FK users, SET NULL)
   - target_amount (NUMERIC, DEFAULT NULL) -- Optional target for progress bar
   - status (TEXT, CHECK ('upcoming', 'active', 'completed'), DEFAULT 'upcoming')
   - created_at, updated_at (TIMESTAMPTZ)
   - UNIQUE(group_id, celebrant_id, year)

2. `chat_rooms` - One per celebration
   - id (UUID, PK)
   - celebration_id (UUID, FK celebrations, CASCADE, UNIQUE)
   - created_at (TIMESTAMPTZ)

3. `chat_messages` - Messages in chat rooms
   - id (UUID, PK)
   - chat_room_id (UUID, FK chat_rooms, CASCADE, NOT NULL)
   - sender_id (UUID, FK users, SET NULL, NOT NULL)
   - content (TEXT, NOT NULL)
   - linked_item_id (UUID, FK wishlist_items, SET NULL) -- For CHAT-03 linking to wishlist items
   - created_at (TIMESTAMPTZ)

4. `celebration_contributions` - Per-celebration pot (user decision from CONTEXT.md)
   - id (UUID, PK)
   - celebration_id (UUID, FK celebrations, CASCADE, NOT NULL)
   - user_id (UUID, FK users, CASCADE, NOT NULL)
   - amount (NUMERIC, NOT NULL, CHECK > 0)
   - created_at, updated_at (TIMESTAMPTZ)
   - UNIQUE(celebration_id, user_id) -- One contribution per user per celebration

5. `gift_leader_history` - Audit trail for reassignments
   - id (UUID, PK)
   - celebration_id (UUID, FK celebrations, CASCADE, NOT NULL)
   - assigned_to (UUID, FK users, SET NULL)
   - assigned_by (UUID, FK users, SET NULL) -- NULL = auto-assigned
   - reason (TEXT, CHECK ('auto_rotation', 'manual_reassign', 'member_left'), NOT NULL)
   - created_at (TIMESTAMPTZ)

**RLS Policies (SECURITY CRITICAL):**

For `celebrations`:
- Enable RLS immediately after CREATE TABLE
- Group members can view all celebrations in their groups (celebrant CAN see their celebration exists)

For `chat_rooms`:
- CRITICAL: Exclude celebrant using join pattern:
  ```sql
  EXISTS (
    SELECT 1 FROM celebrations c
    JOIN group_members gm ON gm.group_id = c.group_id
    WHERE c.id = chat_rooms.celebration_id
      AND gm.user_id = auth.uid()
      AND c.celebrant_id != auth.uid()  -- EXCLUDES CELEBRANT
  )
  ```

For `chat_messages`:
- Same celebrant exclusion pattern via join through chat_rooms
- INSERT: sender_id = auth.uid() AND celebrant exclusion check

For `celebration_contributions`:
- SELECT: celebrant exclusion (same pattern)
- INSERT/UPDATE: user_id = auth.uid() AND celebrant exclusion

For `gift_leader_history`:
- Group members can view (no celebrant exclusion - history is not secret)

**Indexes:**
- celebrations(group_id)
- celebrations(celebrant_id)
- celebrations(event_date)
- chat_messages(chat_room_id, created_at)
- celebration_contributions(celebration_id)

**Realtime:**
- Enable for chat_messages: `ALTER PUBLICATION supabase_realtime ADD TABLE chat_messages;`

**Update types/database.types.ts:**
Add TypeScript interfaces for all 5 new tables following existing pattern in file.
  </action>
  <verify>
1. `cat supabase/migrations/20260202000005_celebrations.sql | grep -c "CREATE TABLE"` returns 5
2. `cat supabase/migrations/20260202000005_celebrations.sql | grep -c "celebrant_id != auth.uid()"` returns at least 4 (chat_rooms SELECT, chat_messages SELECT, chat_messages INSERT, celebration_contributions)
3. `grep -c "celebrations:" types/database.types.ts` returns 1
4. `npx tsc --noEmit` passes (TypeScript compiles)
  </verify>
  <done>
Migration file creates 5 tables with proper RLS policies that exclude celebrants from viewing chat/contributions. TypeScript types updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Gift Leader utilities and celebration CRUD</name>
  <files>
    lib/celebrations.ts
  </files>
  <action>
Create celebration utilities following patterns from 02-RESEARCH.md.

**Export these functions:**

1. `getNextGiftLeader(groupId: string, celebrantId: string): Promise<string>`
   - Get all group members with their birthdays
   - Sort by birthday (month-day, not year) using PostgreSQL ORDER BY or client sort
   - Use EXTRACT(MONTH FROM birthday), EXTRACT(DAY FROM birthday) pattern
   - Find celebrant position in sorted list
   - Return user_id of next person in rotation (wraps around with modulo)
   - Edge cases:
     - 2-person group: other person is always leader
     - Same birthday: use user_id as stable tiebreaker
     - Throw error if < 2 members

2. `createCelebration(groupId: string, celebrantId: string, eventDate: Date): Promise<Celebration>`
   - Validate user is group member
   - Call getNextGiftLeader to auto-assign
   - Insert celebration with calculated gift_leader_id
   - Create chat_room for this celebration
   - Insert gift_leader_history with reason 'auto_rotation'
   - Return created celebration

3. `reassignGiftLeader(celebrationId: string, newLeaderId: string): Promise<void>`
   - Verify current user is group admin
   - Update celebrations.gift_leader_id
   - Insert gift_leader_history with assigned_by = current user, reason = 'manual_reassign'

4. `getCelebrations(userId: string): Promise<Celebration[]>`
   - Get all celebrations where user is a group member
   - Filter out where user is celebrant (they shouldn't see details)
   - Include celebrant info (name, avatar), gift_leader info, contribution totals
   - Order by event_date ASC

5. `getCelebration(celebrationId: string): Promise<CelebrationDetail>`
   - Get single celebration with full details
   - RLS handles celebrant exclusion automatically
   - Include gift_leader_history for the celebration

**Types to define:**
```typescript
interface Celebration {
  id: string;
  group_id: string;
  celebrant_id: string;
  event_date: string;
  year: number;
  gift_leader_id: string | null;
  target_amount: number | null;
  status: 'upcoming' | 'active' | 'completed';
  created_at: string;
  celebrant?: { display_name: string; avatar_url: string | null };
  gift_leader?: { display_name: string; avatar_url: string | null };
  total_contributed?: number;
}
```

Use supabase client from existing lib/supabase.ts pattern.
  </action>
  <verify>
1. `grep -c "export.*function\|export const" lib/celebrations.ts` returns at least 5
2. `grep "getNextGiftLeader" lib/celebrations.ts` finds the function
3. `grep "reassignGiftLeader" lib/celebrations.ts` finds the function
4. `npx tsc --noEmit` passes
  </verify>
  <done>
lib/celebrations.ts exports Gift Leader assignment algorithm with edge case handling, celebration CRUD operations, and proper TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create celebrations list and detail screens</name>
  <files>
    app/(app)/(tabs)/celebrations.tsx
    app/(app)/celebration/[id].tsx
    app/(app)/(tabs)/_layout.tsx
    components/celebrations/CelebrationCard.tsx
    components/celebrations/GiftLeaderBadge.tsx
  </files>
  <action>
**Create celebrations tab screen `app/(app)/(tabs)/celebrations.tsx`:**
- Fetch celebrations using getCelebrations
- Display list using FlashList (already installed)
- Each item shows: celebrant name, event date, Gift Leader badge if user is leader
- Empty state: "No upcoming celebrations"
- Navigate to celebration detail on tap
- Show "You are the Gift Leader" badge prominently for assigned celebrations

**Create celebration detail screen `app/(app)/celebration/[id].tsx`:**
- Fetch celebration using getCelebration
- Header: Celebrant name and birthday
- Gift Leader section:
  - Show current Gift Leader with badge
  - If current user IS Gift Leader: "You are coordinating this gift!"
  - If user is group admin: Show "Reassign" button
- Reassign modal (for admins):
  - List other group members (except celebrant)
  - On select: call reassignGiftLeader
- Placeholder sections for:
  - Chat (will be implemented in 02-02)
  - Contributions (will be implemented in 02-02)
- Status indicator (upcoming/active/completed)

**Update tab layout `app/(app)/(tabs)/_layout.tsx`:**
- Add celebrations tab with gift icon (MaterialCommunityIcons "gift" or "party-popper")
- Position between groups and notifications tabs

**Create GiftLeaderBadge component `components/celebrations/GiftLeaderBadge.tsx`:**
- Simple badge component showing "Gift Leader" text
- Variant for "You are Gift Leader" (highlighted)
- Use Gluestack Badge component if available, or styled View

**Create CelebrationCard component `components/celebrations/CelebrationCard.tsx`:**
- Props: celebration, isGiftLeader, onPress
- Shows celebrant avatar + name
- Shows event date formatted nicely (e.g., "March 15")
- Shows Gift Leader badge if isGiftLeader
- Pressable for navigation

**Navigation:**
- From celebrations list: navigate to `/celebration/[id]`
- Use expo-router's Link or router.push
  </action>
  <verify>
1. File exists: `ls app/(app)/(tabs)/celebrations.tsx`
2. File exists: `ls app/(app)/celebration/[id].tsx`
3. Tab added: `grep -c "celebrations" app/(app)/(tabs)/_layout.tsx` returns at least 1
4. Components exist: `ls components/celebrations/`
5. `npx tsc --noEmit` passes
  </verify>
  <done>
Celebrations tab shows list of celebrations. Detail screen shows Gift Leader info with admin reassignment capability. UI clearly indicates when user is the Gift Leader.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema verification:**
   - Run: `cat supabase/migrations/20260202000005_celebrations.sql | head -50`
   - Confirm 5 CREATE TABLE statements
   - Confirm RLS enabled on all tables
   - Confirm celebrant exclusion in chat/contribution policies

2. **TypeScript compilation:**
   - Run: `npx tsc --noEmit`
   - Should pass with no errors

3. **Utility exports:**
   - Run: `grep "export" lib/celebrations.ts`
   - Should show getNextGiftLeader, createCelebration, reassignGiftLeader, getCelebrations

4. **Screen files exist:**
   - Run: `ls -la app/(app)/(tabs)/celebrations.tsx app/(app)/celebration/\[id\].tsx`
   - Both files should exist

5. **Tab navigation:**
   - Check `app/(app)/(tabs)/_layout.tsx` includes celebrations tab
</verification>

<success_criteria>
- [ ] 5 new database tables created with comprehensive RLS
- [ ] Celebrant exclusion policies use correct join pattern with `celebrant_id != auth.uid()`
- [ ] Gift Leader assignment algorithm handles edge cases (2-person, same birthday)
- [ ] Celebrations tab shows accessible celebrations
- [ ] Celebration detail shows Gift Leader prominently
- [ ] Admin can reassign Gift Leader
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-celebrations-coordination/02-01-SUMMARY.md`
</output>
