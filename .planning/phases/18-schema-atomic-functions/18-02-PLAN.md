---
phase: 18-schema-atomic-functions
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - types/database.types.ts
  - lib/claims.ts
  - lib/personalDetails.ts
  - lib/memberNotes.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript types for gift_claims, personal_details, and member_notes tables exist in database.types.ts with Row/Insert/Update shapes"
    - "Convenience type exports (GiftClaim, PersonalDetails, MemberNote) are available from types/database.types.ts"
    - "lib/claims.ts exports claimItem(), unclaimItem(), getItemClaimStatus(), and getClaimsForItems() functions"
    - "lib/personalDetails.ts exports getPersonalDetails(), upsertPersonalDetails() functions"
    - "lib/memberNotes.ts exports getNotesAboutUser(), createNote(), deleteNote() functions"
    - "All service functions use the supabase client from lib/supabase.ts and follow existing { data, error } return patterns"
  artifacts:
    - path: "types/database.types.ts"
      provides: "Database type definitions for v1.3 tables"
      contains: "gift_claims"
    - path: "lib/claims.ts"
      provides: "Gift claim service functions wrapping RPC calls"
      exports: ["claimItem", "unclaimItem", "getItemClaimStatus", "getClaimsForItems"]
    - path: "lib/personalDetails.ts"
      provides: "Personal details CRUD service"
      exports: ["getPersonalDetails", "upsertPersonalDetails"]
    - path: "lib/memberNotes.ts"
      provides: "Member notes CRUD service"
      exports: ["getNotesAboutUser", "createNote", "deleteNote"]
  key_links:
    - from: "lib/claims.ts"
      to: "supabase RPC (claim_item, unclaim_item, get_item_claim_status)"
      via: "supabase.rpc() calls"
      pattern: "supabase\\.rpc\\("
    - from: "lib/personalDetails.ts"
      to: "supabase.from('personal_details')"
      via: "standard Supabase query builder"
      pattern: "from\\('personal_details'\\)"
    - from: "lib/memberNotes.ts"
      to: "supabase.from('member_notes')"
      via: "standard Supabase query builder"
      pattern: "from\\('member_notes'\\)"
---

<objective>
Add TypeScript type definitions for the three new v1.3 tables and create service library modules that wrap database operations for claims, personal details, and member notes.

Purpose: Provide typed data access layer that Phases 19-22 UI code imports. Service functions encapsulate RPC calls (claims) and standard queries (personal details, notes), following existing codebase patterns from lib/contributions.ts and lib/chat.ts.

Output: Updated database types file and three new lib/ service modules.
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-schema-atomic-functions/18-CONTEXT.md
@.planning/phases/18-schema-atomic-functions/18-RESEARCH.md
@.planning/phases/18-schema-atomic-functions/18-01-SUMMARY.md

Reference existing patterns:
@types/database.types.ts
@types/index.ts
@lib/contributions.ts
@lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add v1.3 table types to database.types.ts and export convenience types</name>
  <files>types/database.types.ts</files>
  <action>
Add three new table type definitions to the `Database['public']['Tables']` interface in `types/database.types.ts`, following the existing Row/Insert/Update pattern used by all other tables. Insert them alphabetically among existing table entries.

**gift_claims table types:**
```typescript
gift_claims: {
  Row: {
    id: string
    wishlist_item_id: string
    claimed_by: string
    claim_type: 'full' | 'split'
    amount: number | null
    status: 'claimed' | 'purchased' | 'delivered'
    created_at: string
    updated_at: string
  }
  Insert: {
    id?: string
    wishlist_item_id: string
    claimed_by: string
    claim_type?: 'full' | 'split'
    amount?: number | null
    status?: 'claimed' | 'purchased' | 'delivered'
    created_at?: string
    updated_at?: string
  }
  Update: {
    id?: string
    wishlist_item_id?: string
    claimed_by?: string
    claim_type?: 'full' | 'split'
    amount?: number | null
    status?: 'claimed' | 'purchased' | 'delivered'
    created_at?: string
    updated_at?: string
  }
}
```

**member_notes table types:**
```typescript
member_notes: {
  Row: {
    id: string
    group_id: string
    about_user_id: string
    author_id: string
    content: string
    created_at: string
  }
  Insert: {
    id?: string
    group_id: string
    about_user_id: string
    author_id: string
    content: string
    created_at?: string
  }
  Update: {
    id?: string
    group_id?: string
    about_user_id?: string
    author_id?: string
    content?: string
    created_at?: string
  }
}
```

**personal_details table types:**
```typescript
personal_details: {
  Row: {
    id: string
    user_id: string
    sizes: Json
    preferences: Json
    external_links: Json
    created_at: string
    updated_at: string
  }
  Insert: {
    id?: string
    user_id: string
    sizes?: Json
    preferences?: Json
    external_links?: Json
    created_at?: string
    updated_at?: string
  }
  Update: {
    id?: string
    user_id?: string
    sizes?: Json
    preferences?: Json
    external_links?: Json
    created_at?: string
    updated_at?: string
  }
}
```

Add convenience type exports at the bottom alongside existing ones:
```typescript
export type GiftClaim = Database['public']['Tables']['gift_claims']['Row'];
export type PersonalDetails = Database['public']['Tables']['personal_details']['Row'];
export type MemberNote = Database['public']['Tables']['member_notes']['Row'];
```

Also add typed interfaces for the JSONB column shapes (these are application-level types, not database Row types):

```typescript
// JSONB shape interfaces for personal_details columns
export interface PersonalSizes {
  shirt?: string;
  shoe?: string;
  pants?: string;
  ring?: string;
  dress?: string;
  jacket?: string;
}

export interface PreferenceTag {
  label: string;
  custom?: boolean;
}

export interface PersonalPreferences {
  colors?: PreferenceTag[];
  brands?: PreferenceTag[];
  interests?: PreferenceTag[];
  dislikes?: PreferenceTag[];
}

export interface ExternalLink {
  url: string;
  label?: string;
  platform?: string;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -20` to check for TypeScript compilation errors in the types file.
Verify all 3 new table entries exist: `grep -c 'gift_claims\|member_notes\|personal_details' types/database.types.ts` should return at least 6 (2 per table: in Tables and in convenience exports).
  </verify>
  <done>
Database type definitions exist for all three v1.3 tables (gift_claims, personal_details, member_notes) with Row/Insert/Update shapes. Convenience types GiftClaim, PersonalDetails, MemberNote are exported. JSONB shape interfaces (PersonalSizes, PersonalPreferences, ExternalLink) provide typed access to flexible JSONB columns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create service library modules for claims, personal details, and notes</name>
  <files>lib/claims.ts, lib/personalDetails.ts, lib/memberNotes.ts</files>
  <action>
Create three new service library files following the pattern from `lib/contributions.ts` (import supabase client, import Database types, export async functions with JSDoc comments).

**lib/claims.ts** — Gift claims service wrapping RPC functions:

```typescript
import { supabase } from './supabase';
import type { Database, GiftClaim } from '../types/database.types';

// Extended claim type with claimer info (for non-celebrant views)
export interface ClaimWithUser extends GiftClaim {
  claimer?: {
    id: string;
    full_name: string | null;
    avatar_url: string | null;
  };
}

// RPC response type
interface ClaimResponse {
  success: boolean;
  claim_id?: string;
  error?: string;
}

/**
 * Claim a wishlist item via atomic RPC function.
 * Prevents race conditions server-side.
 */
export async function claimItem(
  itemId: string,
  claimType: 'full' | 'split' = 'full',
  amount?: number
): Promise<{ data: ClaimResponse | null; error: Error | null }> {
  // Call the claim_item RPC function
  const { data, error } = await supabase.rpc('claim_item', {
    p_item_id: itemId,
    p_claim_type: claimType,
    p_amount: amount ?? null,
  });
  if (error) return { data: null, error };
  return { data: data as ClaimResponse, error: null };
}

/**
 * Unclaim an item via RPC. Only the claimer can unclaim.
 * Instant unclaim — no time limit.
 */
export async function unclaimItem(
  claimId: string
): Promise<{ data: ClaimResponse | null; error: Error | null }> {
  const { data, error } = await supabase.rpc('unclaim_item', {
    p_claim_id: claimId,
  });
  if (error) return { data: null, error };
  return { data: data as ClaimResponse, error: null };
}

/**
 * Get claim status for items owned by the current user (celebrant view).
 * Returns only boolean is_claimed — no claimer identity.
 * Uses SECURITY DEFINER function for safety.
 */
export async function getItemClaimStatus(
  itemIds: string[]
): Promise<{ data: { wishlist_item_id: string; is_claimed: boolean }[] | null; error: Error | null }> {
  const { data, error } = await supabase.rpc('get_item_claim_status', {
    p_item_ids: itemIds,
  });
  if (error) return { data: null, error };
  return { data: data as { wishlist_item_id: string; is_claimed: boolean }[], error: null };
}

/**
 * Get full claim details for a list of items (non-celebrant view).
 * RLS ensures the item owner cannot see these.
 * Includes claimer profile info.
 */
export async function getClaimsForItems(
  itemIds: string[]
): Promise<{ data: ClaimWithUser[] | null; error: Error | null }> {
  const { data, error } = await supabase
    .from('gift_claims')
    .select(`
      *,
      claimer:users!gift_claims_claimed_by_fkey(id, full_name, avatar_url)
    `)
    .in('wishlist_item_id', itemIds)
    .order('created_at', { ascending: true });
  if (error) return { data: null, error };
  return { data: data as ClaimWithUser[], error: null };
}
```

**lib/personalDetails.ts** — Personal details CRUD:

```typescript
import { supabase } from './supabase';
import type {
  Database,
  PersonalDetails,
  PersonalSizes,
  PersonalPreferences,
  ExternalLink,
} from '../types/database.types';

// Typed personal details with parsed JSONB
export interface TypedPersonalDetails {
  id: string;
  user_id: string;
  sizes: PersonalSizes;
  preferences: PersonalPreferences;
  external_links: ExternalLink[];
  created_at: string;
  updated_at: string;
}

/**
 * Get personal details for a user.
 * Any authenticated user can read (for gift-giving context).
 * Returns null if user hasn't set up personal details yet.
 */
export async function getPersonalDetails(
  userId: string
): Promise<{ data: TypedPersonalDetails | null; error: Error | null }> {
  const { data, error } = await supabase
    .from('personal_details')
    .select('*')
    .eq('user_id', userId)
    .maybeSingle();
  if (error) return { data: null, error };
  return {
    data: data ? {
      ...data,
      sizes: (data.sizes ?? {}) as PersonalSizes,
      preferences: (data.preferences ?? {}) as PersonalPreferences,
      external_links: (data.external_links ?? []) as ExternalLink[],
    } : null,
    error: null,
  };
}

/**
 * Create or update personal details for the current user.
 * Uses upsert on user_id (UNIQUE constraint).
 * Owner-only via RLS.
 */
export async function upsertPersonalDetails(details: {
  sizes?: PersonalSizes;
  preferences?: PersonalPreferences;
  external_links?: ExternalLink[];
}): Promise<{ data: TypedPersonalDetails | null; error: Error | null }> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { data: null, error: new Error('Not authenticated') };

  const { data, error } = await supabase
    .from('personal_details')
    .upsert(
      {
        user_id: user.id,
        sizes: (details.sizes ?? {}) as any,
        preferences: (details.preferences ?? {}) as any,
        external_links: (details.external_links ?? []) as any,
      },
      { onConflict: 'user_id' }
    )
    .select()
    .single();

  if (error) return { data: null, error };
  return {
    data: {
      ...data,
      sizes: (data.sizes ?? {}) as PersonalSizes,
      preferences: (data.preferences ?? {}) as PersonalPreferences,
      external_links: (data.external_links ?? []) as ExternalLink[],
    },
    error: null,
  };
}
```

**lib/memberNotes.ts** — Member notes service:

```typescript
import { supabase } from './supabase';
import type { Database, MemberNote } from '../types/database.types';

// Extended note type with author info
export interface NoteWithAuthor extends MemberNote {
  author?: {
    id: string;
    full_name: string | null;
    avatar_url: string | null;
  };
}

/**
 * Get all notes about a user in a specific group.
 * Subject-exclusion RLS: the about_user cannot see their own notes.
 * Includes author profile info.
 * Ordered by most recent first.
 */
export async function getNotesAboutUser(
  groupId: string,
  aboutUserId: string
): Promise<{ data: NoteWithAuthor[] | null; error: Error | null }> {
  const { data, error } = await supabase
    .from('member_notes')
    .select(`
      *,
      author:users!member_notes_author_id_fkey(id, full_name, avatar_url)
    `)
    .eq('group_id', groupId)
    .eq('about_user_id', aboutUserId)
    .order('created_at', { ascending: false });
  if (error) return { data: null, error };
  return { data: data as NoteWithAuthor[], error: null };
}

/**
 * Create a new note about a member.
 * Cannot write notes about yourself (enforced by RLS).
 * Content limited to 280 characters (enforced by CHECK constraint).
 */
export async function createNote(
  groupId: string,
  aboutUserId: string,
  content: string
): Promise<{ data: MemberNote | null; error: Error | null }> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { data: null, error: new Error('Not authenticated') };

  const { data, error } = await supabase
    .from('member_notes')
    .insert({
      group_id: groupId,
      about_user_id: aboutUserId,
      author_id: user.id,
      content,
    })
    .select()
    .single();
  if (error) return { data: null, error };
  return { data, error: null };
}

/**
 * Delete a note. Only the author can delete (enforced by RLS).
 * Delete-only model — no editing. User must delete and rewrite.
 */
export async function deleteNote(
  noteId: string
): Promise<{ error: Error | null }> {
  const { error } = await supabase
    .from('member_notes')
    .delete()
    .eq('id', noteId);
  return { error };
}
```

All three files should:
- Import from `./supabase` (not `../lib/supabase`)
- Import types from `../types/database.types`
- Use JSDoc comments explaining security model and RLS behavior
- Follow `{ data, error }` return pattern consistent with lib/contributions.ts
- Export named functions (not default exports)
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to check for TypeScript compilation errors.
Verify files exist: `ls lib/claims.ts lib/personalDetails.ts lib/memberNotes.ts`
Verify exports: `grep 'export async function' lib/claims.ts lib/personalDetails.ts lib/memberNotes.ts` should show all expected function names.
  </verify>
  <done>
Three service library modules exist with typed functions: lib/claims.ts (4 functions wrapping RPC and direct queries), lib/personalDetails.ts (2 functions with JSONB type casting), lib/memberNotes.ts (3 functions with author join). All follow existing codebase patterns and provide the data access layer for Phases 19-22.
  </done>
</task>

</tasks>

<verification>
1. `types/database.types.ts` contains gift_claims, personal_details, member_notes in Tables interface
2. Convenience types GiftClaim, PersonalDetails, MemberNote exported
3. JSONB shape interfaces (PersonalSizes, PersonalPreferences, ExternalLink) exported
4. `lib/claims.ts` exports claimItem, unclaimItem, getItemClaimStatus, getClaimsForItems
5. `lib/personalDetails.ts` exports getPersonalDetails, upsertPersonalDetails
6. `lib/memberNotes.ts` exports getNotesAboutUser, createNote, deleteNote
7. All service functions use `supabase` from `./supabase`
8. TypeScript compiles without errors related to new files
</verification>

<success_criteria>
- All three new tables have corresponding TypeScript types in database.types.ts
- Service functions wrap every database operation needed by downstream phases
- claimItem() calls supabase.rpc('claim_item') (not direct INSERT)
- JSONB columns have typed interfaces for application-level access
- Code follows existing lib/ patterns (imports, JSDoc, return types)
</success_criteria>

<output>
After completion, create `.planning/phases/18-schema-atomic-functions/18-02-SUMMARY.md`
</output>
