---
phase: 18-schema-atomic-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260206000001_v1.3_claims_details_notes.sql
autonomous: true

must_haves:
  truths:
    - "gift_claims table exists with partial unique index enforcing one full claim per wishlist item"
    - "personal_details table exists with JSONB columns (sizes, preferences, external_links) and owner-only edit RLS"
    - "member_notes table exists with 280-char limit and subject-exclusion RLS preventing users from reading notes about themselves"
    - "Atomic claim_item() RPC prevents race conditions via SELECT FOR UPDATE SKIP LOCKED"
    - "unclaim_item() RPC deletes only the caller's own claim instantly"
    - "get_item_claim_status() SECURITY DEFINER returns only is_claimed boolean for items owned by the caller (no claimer identity leaked)"
    - "Non-celebrant group members can view full claim details (who claimed what)"
    - "Item owner (celebrant) is blocked from SELECT on gift_claims via RLS"
  artifacts:
    - path: "supabase/migrations/20260206000001_v1.3_claims_details_notes.sql"
      provides: "Complete v1.3 database foundation: 3 tables, RLS policies, indexes, RPC functions"
      contains: "CREATE TABLE public.gift_claims"
  key_links:
    - from: "gift_claims.wishlist_item_id"
      to: "wishlist_items.id"
      via: "FK ON DELETE CASCADE"
      pattern: "REFERENCES public.wishlist_items"
    - from: "member_notes.group_id"
      to: "groups.id"
      via: "FK ON DELETE CASCADE"
      pattern: "REFERENCES public.groups"
    - from: "claim_item() RPC"
      to: "gift_claims table"
      via: "INSERT with FOR UPDATE SKIP LOCKED guard"
      pattern: "SELECT.*FOR UPDATE SKIP LOCKED"
    - from: "get_item_claim_status()"
      to: "gift_claims + wishlist_items"
      via: "SECURITY DEFINER join returning boolean only"
      pattern: "SECURITY DEFINER.*STABLE"
---

<objective>
Create the complete v1.3 database migration: three new tables (gift_claims, personal_details, member_notes) with RLS policies implementing three distinct visibility patterns, atomic RPC functions for race-condition-safe claiming, and celebrant-safe status queries.

Purpose: Establish the database foundation that Phases 19-22 build UI on. No user-facing screens -- pure schema and atomic operations. This is the critical security boundary for gift coordination privacy.

Output: Single migration file containing all tables, policies, functions, indexes, and triggers.
</objective>

<execution_context>
@/home/zetaz/.claude/get-shit-done/workflows/execute-plan.md
@/home/zetaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-schema-atomic-functions/18-CONTEXT.md
@.planning/phases/18-schema-atomic-functions/18-RESEARCH.md

Reference existing migration patterns:
@supabase/migrations/20260205000001_v1.2_groups_schema.sql
@supabase/migrations/20260202000005_celebrations.sql
@supabase/migrations/20260202000003_fix_group_members_recursion.sql
@supabase/migrations/20260201000001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tables, RLS policies, indexes, and triggers</name>
  <files>supabase/migrations/20260206000001_v1.3_claims_details_notes.sql</files>
  <action>
Create migration file `supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` with the following sections:

**PART 1: gift_claims table**
```sql
CREATE TABLE public.gift_claims (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wishlist_item_id UUID REFERENCES public.wishlist_items(id) ON DELETE CASCADE NOT NULL,
  claimed_by UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  claim_type TEXT CHECK (claim_type IN ('full', 'split')) DEFAULT 'full',
  amount NUMERIC CHECK (amount IS NULL OR amount > 0),
  status TEXT CHECK (status IN ('claimed', 'purchased', 'delivered')) DEFAULT 'claimed',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

- Partial unique index: `CREATE UNIQUE INDEX idx_gift_claims_full_unique ON public.gift_claims(wishlist_item_id) WHERE claim_type = 'full';`
- Regular indexes on `wishlist_item_id` and `claimed_by`
- Enable RLS

RLS policies for gift_claims (celebrant partial visibility pattern):
1. **SELECT for non-owners**: User can view claims on items they do NOT own, where the user shares at least one group with the item owner. Use subquery pattern: `NOT EXISTS (SELECT 1 FROM public.wishlist_items wi WHERE wi.id = gift_claims.wishlist_item_id AND wi.user_id = (SELECT auth.uid()))` AND `EXISTS (SELECT 1 FROM public.wishlist_items wi JOIN public.group_members gm_owner ON gm_owner.group_id = wi.group_id AND gm_owner.user_id = wi.user_id JOIN public.group_members gm_viewer ON gm_viewer.group_id = wi.group_id AND gm_viewer.user_id = (SELECT auth.uid()) WHERE wi.id = gift_claims.wishlist_item_id)`.
2. **INSERT**: User can claim items they do NOT own, where they share a group with the item owner. Same group-sharing check as SELECT. WITH CHECK must enforce `claimed_by = (SELECT auth.uid())`.
3. **UPDATE**: Only the claimer can update their own claim. `USING (claimed_by = (SELECT auth.uid()))` with same WITH CHECK.
4. **DELETE**: Only the claimer can delete (unclaim). `USING (claimed_by = (SELECT auth.uid()))`.

IMPORTANT: Use `(SELECT auth.uid())` NOT `auth.uid()` in all policy expressions -- the subquery form is more efficient in PostgreSQL RLS (evaluated once per query, not per row).

**PART 2: personal_details table**
```sql
CREATE TABLE public.personal_details (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL UNIQUE,
  sizes JSONB DEFAULT '{}',
  preferences JSONB DEFAULT '{}',
  external_links JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

- Index on `user_id` (UNIQUE already creates this, but add explicit for clarity if needed)
- Enable RLS

RLS policies for personal_details:
1. **SELECT**: Any authenticated user can view. `USING ((SELECT auth.uid()) IS NOT NULL)`.
2. **INSERT**: Owner only. `WITH CHECK (user_id = (SELECT auth.uid()))`.
3. **UPDATE**: Owner only. `USING (user_id = (SELECT auth.uid())) WITH CHECK (user_id = (SELECT auth.uid()))`.
4. **DELETE**: Owner only. `USING (user_id = (SELECT auth.uid()))`.

**PART 3: member_notes table**
```sql
CREATE TABLE public.member_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id UUID REFERENCES public.groups(id) ON DELETE CASCADE NOT NULL,
  about_user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  author_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL CHECK (char_length(content) <= 280),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

No `updated_at` column (delete-only, no editing per CONTEXT decision).

- Indexes on `(group_id, about_user_id)` and `author_id`
- Enable RLS

RLS policies for member_notes (subject-exclusion pattern):
1. **SELECT**: Group members can view notes EXCEPT notes about themselves. `USING (about_user_id != (SELECT auth.uid()) AND public.is_group_member(group_id, (SELECT auth.uid())))`.
2. **INSERT**: Group members can write notes about OTHER members. `WITH CHECK (author_id = (SELECT auth.uid()) AND about_user_id != (SELECT auth.uid()) AND public.is_group_member(group_id, (SELECT auth.uid())))`.
3. **DELETE**: Author can delete own notes only. `USING (author_id = (SELECT auth.uid()))`.
4. No UPDATE policy (delete-only per CONTEXT decision).

**PART 4: Triggers**
- Add `updated_at` trigger on `gift_claims` using existing `handle_updated_at()` function
- Add `updated_at` trigger on `personal_details` using existing `handle_updated_at()` function
- No trigger on `member_notes` (no `updated_at` column)

**PART 5: Comments**
- Add COMMENT ON TABLE and COMMENT ON COLUMN for all new tables/columns documenting the three RLS patterns

**Style**: Follow the existing migration style from v1.2 (section headers with `-- ============`, `DO $$ RAISE NOTICE $$` at end, `IF NOT EXISTS` where possible for idempotency).
  </action>
  <verify>
Run `cat supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` and confirm:
- Three CREATE TABLE statements (gift_claims, personal_details, member_notes)
- Three ALTER TABLE ENABLE ROW LEVEL SECURITY statements
- Partial unique index on gift_claims(wishlist_item_id) WHERE claim_type = 'full'
- RLS policies: 4 on gift_claims, 4 on personal_details, 3 on member_notes
- Two updated_at triggers (gift_claims, personal_details)
- CHECK constraint on member_notes.content length
- All auth.uid() calls wrapped in (SELECT auth.uid())
  </verify>
  <done>
Tables, indexes, RLS policies, and triggers are defined in the migration file. Three distinct RLS visibility patterns are implemented: celebrant partial visibility (gift_claims), public read with owner-write (personal_details), and subject-exclusion (member_notes).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add atomic RPC functions to migration</name>
  <files>supabase/migrations/20260206000001_v1.3_claims_details_notes.sql</files>
  <action>
Append RPC functions to the migration file created in Task 1, after the triggers section:

**PART 6: RPC Functions**

**Function 1: claim_item()**
```sql
CREATE OR REPLACE FUNCTION public.claim_item(
  p_item_id UUID,
  p_claim_type TEXT DEFAULT 'full',
  p_amount NUMERIC DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_item RECORD;
  v_existing RECORD;
  v_claim_id UUID;
  v_user_id UUID;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Validate claim_type
  IF p_claim_type NOT IN ('full', 'split') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid claim type');
  END IF;

  -- Split claims require positive amount
  IF p_claim_type = 'split' AND (p_amount IS NULL OR p_amount <= 0) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Split claims require a positive amount');
  END IF;

  -- Fetch the item and lock the row to prevent concurrent reads
  SELECT wi.id, wi.user_id, wi.group_id, wi.item_type
  INTO v_item
  FROM public.wishlist_items wi
  WHERE wi.id = p_item_id
  FOR UPDATE SKIP LOCKED;

  IF v_item IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item not found or locked');
  END IF;

  -- Cannot claim own items
  IF v_item.user_id = v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot claim your own item');
  END IF;

  -- Cannot claim Surprise Me or Mystery Box items
  IF v_item.item_type IN ('surprise_me', 'mystery_box') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Special items cannot be claimed');
  END IF;

  -- Verify caller is in a group with the item owner
  IF NOT EXISTS (
    SELECT 1 FROM public.group_members gm_owner
    JOIN public.group_members gm_claimer ON gm_claimer.group_id = gm_owner.group_id
    WHERE gm_owner.user_id = v_item.user_id
      AND gm_claimer.user_id = v_user_id
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not in a shared group with item owner');
  END IF;

  -- For full claims: check no existing full claim
  IF p_claim_type = 'full' THEN
    SELECT id INTO v_existing
    FROM public.gift_claims
    WHERE wishlist_item_id = p_item_id AND claim_type = 'full';

    IF v_existing IS NOT NULL THEN
      RETURN jsonb_build_object('success', false, 'error', 'Item already claimed');
    END IF;

    -- Also block full claim if splits already exist
    IF EXISTS (SELECT 1 FROM public.gift_claims WHERE wishlist_item_id = p_item_id AND claim_type = 'split') THEN
      RETURN jsonb_build_object('success', false, 'error', 'Item has split contributions, cannot full-claim');
    END IF;
  END IF;

  -- For split claims: block if a full claim already exists
  IF p_claim_type = 'split' THEN
    IF EXISTS (SELECT 1 FROM public.gift_claims WHERE wishlist_item_id = p_item_id AND claim_type = 'full') THEN
      RETURN jsonb_build_object('success', false, 'error', 'Item is fully claimed, cannot add split');
    END IF;
  END IF;

  -- Insert the claim
  INSERT INTO public.gift_claims (wishlist_item_id, claimed_by, claim_type, amount)
  VALUES (p_item_id, v_user_id, p_claim_type, p_amount)
  RETURNING id INTO v_claim_id;

  RETURN jsonb_build_object('success', true, 'claim_id', v_claim_id);
END;
$$;
```

**Function 2: unclaim_item()**
```sql
CREATE OR REPLACE FUNCTION public.unclaim_item(p_claim_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_user_id UUID;
  v_deleted INTEGER;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Delete only if caller is the claimer (instant unclaim, no time limit)
  DELETE FROM public.gift_claims
  WHERE id = p_claim_id AND claimed_by = v_user_id;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;

  IF v_deleted = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Claim not found or not yours');
  END IF;

  RETURN jsonb_build_object('success', true);
END;
$$;
```

**Function 3: get_item_claim_status()**
```sql
CREATE OR REPLACE FUNCTION public.get_item_claim_status(p_item_ids UUID[])
RETURNS TABLE(wishlist_item_id UUID, is_claimed BOOLEAN)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = ''
AS $$
DECLARE
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN;
  END IF;

  -- Only return status for items owned by the current user (celebrant safety)
  RETURN QUERY
  SELECT
    wi.id AS wishlist_item_id,
    EXISTS (
      SELECT 1 FROM public.gift_claims gc
      WHERE gc.wishlist_item_id = wi.id
    ) AS is_claimed
  FROM public.wishlist_items wi
  WHERE wi.id = ANY(p_item_ids)
    AND wi.user_id = v_user_id;
END;
$$;
```

**PART 7: Grant execute permissions**
```sql
GRANT EXECUTE ON FUNCTION public.claim_item(UUID, TEXT, NUMERIC) TO authenticated;
GRANT EXECUTE ON FUNCTION public.unclaim_item(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_item_claim_status(UUID[]) TO authenticated;
```

Add function COMMENT ON statements explaining each function's security model and purpose.

End the file with the standard `DO $$ RAISE NOTICE $$` block listing all created objects.
  </action>
  <verify>
Run `grep -c 'CREATE OR REPLACE FUNCTION' supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` and confirm it returns 3.
Run `grep 'SECURITY DEFINER' supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` and confirm 3 occurrences.
Run `grep 'GRANT EXECUTE' supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` and confirm 3 occurrences.
Run `grep 'FOR UPDATE SKIP LOCKED' supabase/migrations/20260206000001_v1.3_claims_details_notes.sql` and confirm at least 1 occurrence.
  </verify>
  <done>
Three atomic RPC functions are defined: claim_item() with race-condition prevention via SELECT FOR UPDATE SKIP LOCKED, unclaim_item() with instant deletion for the claimer, and get_item_claim_status() as SECURITY DEFINER STABLE returning only boolean is_claimed for celebrant safety. All functions have GRANT EXECUTE for authenticated role.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260206000001_v1.3_claims_details_notes.sql`
2. File contains CREATE TABLE for: gift_claims, personal_details, member_notes
3. File contains ENABLE ROW LEVEL SECURITY for all 3 tables
4. File contains 11 RLS policies total (4 + 4 + 3)
5. File contains partial unique index on gift_claims
6. File contains 3 RPC functions (claim_item, unclaim_item, get_item_claim_status)
7. All RPC functions use SECURITY DEFINER
8. claim_item uses FOR UPDATE SKIP LOCKED for atomicity
9. get_item_claim_status filters by wi.user_id = v_user_id (celebrant safety)
10. member_notes SELECT policy has `about_user_id != (SELECT auth.uid())` (subject exclusion)
11. gift_claims SELECT policy excludes item owner (celebrant partial visibility)
</verification>

<success_criteria>
- Single migration file creates all v1.3 database infrastructure
- Three distinct RLS patterns implemented correctly (celebrant partial visibility, public read/owner write, subject exclusion)
- Atomic claiming prevents race conditions
- Celebrant cannot see who claimed their items
- Users cannot see notes about themselves
- Split contributions schema ready (claim_type + amount columns) even though UI is Phase 21
</success_criteria>

<output>
After completion, create `.planning/phases/18-schema-atomic-functions/18-01-SUMMARY.md`
</output>
